---
title: 编译原理学习
tags: 编译原理
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---

# 编译原理

## Reference

*Compilers - Principles Techniques and Tools 2nd*

## (p) 1. Compiler Intro.

**a skectch process of source code become executable file**

```mermaid!
graph TD;
	id[source files] --> preprocessor;
	preprocessor-- source codes -->id1(compiler);
	id1(compiler)-- assemble codes/intermediate code中间代码 -->assembler;
	assembler-- pure codes, i.e. multiple executable files -->id2[Linker/Loaders];
	style id1 fill:#f9f,stroke:#333,stroke-width:4px;
```

> source code to intermediate code is ==compiler front end==, intermediate code to executable file is ==compiler back-end==

e.g. clang use ==IR== as intermediate, all C-family languages(such as C, C++, Object-C) will compiler to ==IR==.

**More detials of compiler**

```mermaid!
graph TD;
	id0(source codes)-->id1(Lexical Analyzer);
	id1(Lexical Analyzer)-- tokens/lexeme词素 -->Parser;
	Parser-->id6(semantic analyzer, static checking);
	id6-- syntax tree -->id2(Intermediate code generator);
	id2--> id3(three-address code/四元式);
	id1---id4(Symbol table);
	Parser---id4;
	id2---id4;
	id6---id4;
	id3-- code optimal 机器有关/机器无关 --> id5(intermediate code);
```

> token/lexeme always represented as tuple '<token-type, attribute-value>'.

## (p) 1. Grammer

### **Chomsky hierarchy** of ==formal grammer==

符号约定(默认情况下适用于本笔记的全局作用域):

* ==`!$V_T$`==: terminal state, 一般用小写字母, 数字或者符号表示
* ==`!$V_N$`==: non-terminal state, 一般用大写字母表示
* ==`!$V$`==: terminal or non-terminal state
* ==`!$\epsilon$`==: empty string
* 希腊字母(e.g. `!$\alpha$`) 用来表示非终结状态和终结状态组成的串

> 以下的文法符号表示都是用的正则基本符号(Kleene operator)

> 下述文法又分为称为 L0，L1，L2，L3 文法

### **Type-0 grammer, i.e., Unrestricted grammar/recursively enumerable**

==`!$[V\epsilon]* \rightarrow [V\epsilon]*$`==

the Automaton is called ==Turing machine==

### **Type-1 grammer, i.e., Context-sensitive grammar**

==`!$\alpha V_N \beta \rightarrow \alpha (V*) \beta$`==

the Automaton is called ==Linear-bounded non-deterministic Turing machine==

> 其中 `!$\alpha$` 和 `!$\beta$` 都是 `!$[V\epsilon]*$`

> 又称 BNF 文法

### **Type-2 grammer, i.e., context-free grammer**

==`!$V_N \rightarrow [V\epsilon]*$`==

the Automaton is called ==Non-deterministic pushdown automaton==

> 在语法分析中普遍使用

> Type-2 grammer 有两种定义

如果由产生式 `!$A \rightarrow \alpha$` 则 `!$\beta = \lambda A \sigma \Rightarrow \lambda \alpha \sigma = \phi, \beta \Rightarrow \phi$`, `!$\phi$` 可以由 `!$\beta$` **直接推导** 出来。

若 `!$\alpha = v_0 \Rightarrow v_1 \Rightarrow \cdots \Rightarrow v_n = \beta$`, 则称 `!$\beta$` 可以由 `!$\alpha$` **推导** 出来。

**句型（sentential form）** 是由开始状态 `!$S$` 推导出来的（可能）含有非终结状态的串。

**句子** 是全部由终结状态组成的串。

从最左到右替换非终结符称为左推导，相反的就是最右推导， **最右推导** 又称 **规范推导**， 左推导和右推导所得句型分别称为 **左句型** 和 **右句型（规范句型）**

 > 不一定所有句型都有最右或最左推导。

**规约(规约， reduction)** 就是推导的逆过程， 规范规约也就是最左规约，每次规约的都是当前符号串的最左边部分。

设 `!$\alpha, \delta \in V^*, \beta \in V^+$` 是文法 `!$G[S]$` 的句型，若对于 `!$A \in V_N$` 有 `!$S \overset{*}{\Rightarrow} \alpha A \delta, A \overset{+}{\Rightarrow} \beta$` 则称 `!$\beta$` 是句型  `!$\alpha \beta \delta$`  相对于非终结符 A 的短语（如果 `!$A \Rightarrow \beta$` 则称直接短语）。

一个句型的最左直接短语称为此句型的 **句柄（handle，在龙书中产生式 `!$A \Rightarrow \beta$` 叫做句柄）**。

### **Type-3 grammer, i.e., regular grammer**

右线性文法(right regular, 最常用)

==`!$V_N \rightarrow V_T V_N^+$`==

> 在词法分析中普遍使用

左线性文法(left regular, 左边跟右边的 `!$V_N$` 正好跟右线性文法相反)

==`!$V_N \rightarrow V_N^+ V_T$`==

the Automaton is called ==Finite state automaton== (DFA/NFA)

> Type-1 到 Type-3 都可以表示成一个 4-tuple: ==`!$(V, \Sigma, F, S, Z)$`==
> `!$V$` 是一个有限集合, 为所有非终结状态集, `!$\Sigma$` 为字母表(Vocabulary), `!$F$` 为 **产生式（Production）** 集合, `!$S$` 为开始状态(只有一个), `!$Z$` 为终结状态集合.

**等价性**

如果两个 Automaton 产生的所有串的集合(**Language, 语言， L(G)**)相同的话, 则称这两个 Automaton 等价, 所以有定理: **对于字母表 `!$\Sigma$` 上的任一 NFA `!$M$`, 必存在 `!$\Sigma$` 上与 M 等价的 DFA `!$M'$`**.

> 然而对于 **前后文无关文法(Type-2 grammer)** 等价问题是 **不可判定** 的.

### Derivations(推导)

就是从开始符号出发, 不断用产生式的右部替换左部的状态一直到终结符号(terminals), 就是一个文法推导出来的符号串(string), 所以可能推导出来的符号串（句子）的集合为 **语言(language)**.

**语法分析(Parsing)** 就是给定一串终结符, 找出如何从这个文法(**这里的文法指的是上下文无关文法, i.e., Type-2 grammer, 如果没有特殊说明, 在语法分析中所说的文法都是上下文无关文法** )的开始符号推导出该串.

### **语法分析树(Parse Tree)** 由文法推导出来的一个终结符号串生成(yield)

* 根为开始符号(状态)
* 叶子为 `!$\epsilon$` 或终结符号
* 中间结点(interior node) 为非终结状态
* 如果一个结点 `!$A$` 有多个连接的孩子结点 `!$\alpha_1 \alpha_2 \cdots \alpha_n$`, 其中 `!$\alpha$` 表示终结状态或非终结状态, 则这个产生式表示为 `!$A \rightarrow \alpha_1 \alpha_2 \cdots \alpha_n$`, 当然 `!$A \rightarrow \epsilon$` 亦是合法的.

> 一般推导都是从最左到右替换非终结符(也就是 **最左推导**）

**二义性(Ambiguity)**

一个文法的终结符号串可以通过不止一种语法树遍历出来.

> 一般需要使用没有二义性的文法或者对有二义性的文法添加限制规则来分析语法

在很多的编程语言中, 运算符(Operator)都会有自己的 **结合性(Associativity)** 和 **优先级(Precedence)**.

* 结合性常常表现为递归, 左结合一般表示为 **(直接)左递归(也就是产生式的右部的最左状态就是左部状态, e.g., `!$A \rightarrow A \alpha$`)**

> 含有递归的文法产生的语言是 **无限的**

* 低优先级的运算符的产生式推导出高优先级的运算符的产生式

结合性和优先级都会影响语法分析树的生成, 常常可以作为消除二义性的方法.

## 语法制导翻译（Syntax-Directed Translation)

一棵语法分析树的所有非叶子结点都标记上 **属性（attribute）** 来作为 **注释（annotation）** 进而形成一颗注释语法分析树。

**属性** 是与程序构造有关的量，一般是当前所在非终结状态的有关（翻译）信息（e.g., 表达式的数据类型，生成代码中的指令数目， etc.），并且要定义一套 **语义规则（semantic rule）** 计算产生式中的符号相关联的属性。属性很多时候是由孩子结点的属性规约而成的。

**翻译方案（translation scheme）** 就是在遍历这个注释树的时候如何翻译为程序片段，我们可以在产生式中嵌入语义动作（semantic action）来用于描述翻译结果（用来输出结果）。

## 语法分析（Parser）

> 虽然上下文无关文法的语法分析器一般都是 O(n^3) 的 time complexity， 不过通过设计高效的文法， 一般可以做到 linear time。

用语法分析结合之前加入的语义动作便可以完成翻译器的实现。

### 自顶向下（top-down）分析

输入指针（ 输入当前的非终结符号被称为向前看（look ahead）符号）指向输入串的第一个元素，语法分析树的箭头从标号为非终结结点的根结点开始， 从它的多个产生式中推导出符合该输入元素的生成式（中的对应终结符号， 并且是从产生式的最左边符号开始， **最左规约**）， 就是不断地去自顶向下从左往右试探，如果遇到不合适就 **回溯** ，再去尝试其他得产生式。

**预测分析法** 

是一种 **递归下降分析法（recursive-descent parsing， 文法的每一个非终结符号都有一个对应的过程，i.e., 无返回值函数）** 的简单形式（不会回溯的递归下降）。

> 所一个非终结符里面就对应一个过程，一个非终结符能推导出多个产生式的话，该非终结符对应的过程里面就会有 **switch-case** 结果来跳转到对应的产生式序列，产生式中的终结符用 **match** 过程表示，非终结符又会对应一个过程，就这样一直递归下去。

![Example](./images/1528891611534.png)

预测分析法必须要知道一个产生式体所有可能生成的串的第一个符号组成的集合（**FIRST 集**），这样才能在一个非终结符号能推导出多个产生式的时候用 **switch-case** 结构。也就是说所有产生式都必须直接或者能推导为以终结符号开头（i.e., 没有左递归），并且如果有 `!$A \rightarrow \alpha, A \rightarrow \beta$` 那么必须有 **FIRST（A）** 和 **FIRST（B）** 不相交（ `!$\epsilon$` 除外）

在没有其他产生式可用时， `!$\epsilon$`-产生式为默认选择（也就是什么也不做，空的过程）。e.g., 对于产生式：

![production optexpr](./images/1528892222655.png)

一般 ==optexpr== 过程可描述为：

![procedure optexpr](./images/1528892288759.png)

**消除(直接)左递归**

> 使直接左递归变成右递归

对于产生式 `!$A \rightarrow A \alpha | \beta$`

可以转化为：

```mathjax!
$
A \rightarrow \beta R \\
R \rightarrow \alpha R | \epsilon
$
```
> 左递归的消除必须在添加好语义动作之后进行

**翻译器的化简**

* 消除尾递归：可以将过程中调用的尾递归用 **while 循环** 替代（一般来说现代 gcc 和 javac 编译器都可以完成简单的消除尾递归）
* 合并过程，将简单的直接调用过程直接 inline 展开到过程中。


## (p) 2. Lexical Analyzer

> 成熟的词法分析生成器工具：jflex

> 词法分析一般会构造符号表给语法分析使用，并且对于嵌套作用域的语言来说，还需要用类似于栈的形式来新建和推出块作用域符号表。

词法分析使用正则表达式(Type-3 grammer), 并且需要构造出对应的 FA(有限自动机, DFA/NFA).

[正则表达式转自动机的算法](https://github.com/DCMMC/SimpleReg2Automata/blob/master/src/main/java/tk/dcmmc/Reg2Automata.java)

### construct `!$\epsilon$`-NFA from regex

使用 Dijkstra 双栈表达式求值算法, 构造出一个中缀表达式树或者直接一边执行表达式求值一边进行正则表达式操作构造, 使用图来保存自动机.

正则表达式运算符优先级(由高到低):

* ==(== left parentheses
* ==\*==(left-associative) 
* concatenation (left-associative)
* ==|== (left-associative) 
* ==)== right parentheses

Thompson 法

![union op](./images/1529220258246.png)

![concat op](./images/1529220298770.png)

![closure op](./images/1529220321364.png)

### construct DFA from `!$\epsilon$`-NFA

使用 **子集构造法(subset construction)**.

![Sketch](./images/1529220908810.png)

### minimized-DFA

子集划分法

supposed there are two states (a set of DFA states represents one minimized-DFA state) and we iterate all the states in all the sets, if there are two states a, b in same states set T_i, if input any symbol s from alphabet \Sigma, f(a, s) = T_j but f(b, s) = T_k, a and b go to different states set, so a and b are not equality states, they should be in different sets. loop the procedure until all elements in same set is equality.

> 总的来说就是把划分为非终结和终结状态这两个集合, 然后再根据状态是否等价(等价也就是说经过词汇表中的所有符号得到的输出符号都是一样的)继续划分, 直到没有可划分的了

![minimize the number of states](./images/1529221671997.png)

## (p) 3. Parser

> 成熟的语法分析翻译方案构造器：Yacc

一个文法可能有多棵语法树生成同一给定的终结符号串, 这种文法被称为具有 **二义性(ambiguous)**, 必须要附加一些规则来 **消除二义性**.

> （抽象）语法树的全结点由终结符号构成，语法分析树的结点除了叶子结点为终结符号之外其他结点为非终结符号。

处理文法的语法分析器：
* 通用（universal， inefficient）
* top-down
* bottom-up

语法分析器的输入都是从左向右，一个一个符号地扫描的。

语法错误：
* 词法错误
* 语法错误
* 语义错误
* 逻辑错误

### 消除二义性

#### **消除左递归**


**消除直接左递归**

见 Intro 部分的自顶向下分析中的消除直接左递归方法。

**消除多个直接左递归**

![eliminate direct left recursion](./images/1529225251238.png)

**消除（直接/间接）左递归**

> 要求输入文法 ==G== 没有闭环和 `!$\epsilon$`-产生式， 其实就是相当于展开回溯，把间接左递归变成直接左递归。

![eliminate left recursion](./images/1529225063138.png)

#### **消除左公因子**

对于如下具有左公因子的产生式，我们很容易产生很多悬空的 ==else== 子句（因为错误的把本来应该是第二种产生式的句型推导成了第一种）

![example](./images/1529225566289.png)

我们可以提取出最长公共前缀，然后

![method](./images/1529225764721.png)

### FIRST 集和 FOLLOW 集

==FIRST(`!$\alpha$`)== 表示所有可以从 `!$\alpha$` 推导出来的串的首符号集合（如果`!$\alpha \overset{*}{\Rightarrow} \epsilon$`, 那么 `!$\epsilon$` 也包含在 ==FIRST(`!$\alpha$`)== 中）。e.g. 预测分析法就需要用到 FIRST 集。

构造 FIRST 集的三大规则：

![rules](./images/1529234244001.png)

==FOLLOW(A)== 就是在所有含有 A 的句型中紧跟在 A 后面的非终结符号的集合（中间可能会由一些 `!$\epsilon$`-表达式的左部的非终结符号， 如果 A 式句型的最右符号，则符号 ==$== （有些书也用 ==#==）也包含在 ==FOLLOW(A)== 中， ==$== 是一个特殊的终结符号标记）。

构造 FOLLOW 的规则：

![rules](./images/1529234372979.png)

### 自顶向下分析法

先序遍历地创建语法分析树，也就是寻找输入串地最左推导。

> top-down 一般就是用递归下降算法。

前面 Intro 介绍的预测分析技术就是递归下降算法地不带回溯地特殊情况。如果要构建能支持回溯的递归下降算法，加入对应于 A 的过程，当尝试完所有的 A-产生式之后，将会回溯输入指针（look ahead 指针），所以需要提前保存好原来的向前看指针。

前面 Intro 提到的 **预测分析法** 只适用于 ==LL(1)== 文法。 ==LL(1)== 表示 **从左到右（第一个L），最左推导（第二个L），只需要一个 look ahead 向前看指针（1的含义）**。	

==LL(1)== 文法的特点

* 无二义性
* 无左递归
* 足以描述打大部分程序设计语言的构造

一个文法 ==G== 是 ==LL(1)== 文法的条件

对于任意两个不同的不同右部相同左部的产生式 `!$A \rightarrow \alpha | \beta$` 都有

* ==First(`!$\alpha$`)== 与 ==Follow(`!$\beta$`)== 不相交
* 如果 `!$\beta \overset{*}{\Rightarrow} \epsilon$`, 那么 ==First(`!$\alpha$`)== 与 ==Follow(A)== 不能相交，同理 `!$\alpha$` 也要满足这个条件。

> 条件 1，2 都是为了确保对于当前lookahead 指针和当前非终结状态的所有产生式，只会匹配出唯一的一个产生式（或者失败）

**非 LL(1) 文法改造成 LL(1) 文法就是不断地消除左递归和提取左公因子**

构造 ==LL(1)== 预测分析表

![map](./images/1529236803142.png)

> 上述算法可以用于任意的 **L1 文法**，不过对于 ==LL(1)== 文法，分析表中的每个条目至多有一个产生式。

![LL(1)](./images/1529237651850.png)

> LL(1) 文法的状态转换图，每一个非终结符号都有一个图，边上为产生式右部的符号。

预测分析中的递归也可以用栈来模拟（用分析表来驱动）。

e.g. 对下面的 ==LL(1)== 文法推导出 **id + id \* id**

![example](./images/1529238581048.png)

![map](./images/1529238558762.png)

![stack](./images/1529238540013.png)

#### **错误恢复**

当栈顶的终结符号与输入符号不匹配或者没有对应的 M\[A, a] 条目的时候，就是发生了语法错我。

// TODO

### 自底向上分析法

对输入串进行最左归约。

**移入-归约（Shift-Reduce）语法分析**

用一个栈来保存文法符号（终结/非终结），用一个缓冲区保存输入串剩余的符号，栈顶和输入缓冲区用 ==$== 表示。

移入就是将缓冲区的符号移到栈中，一个一个移动，直到可以对栈顶的一个符号串（句柄）进行归约为止，一直循环，直到遇到了错误或者栈中只有开始符号并且缓冲区为空。

对于有二义性的文法，移入和归约就会产生冲突（移入和归约都可以，不知道选择哪一个），还有些 L1 文法可能会导致归约-归约冲突（有多种归约）。

==LR(k)== 表示 **对输入从左向右扫描（L），反向构造出一个最右推导序列（R），k 表示向前看的符号数量（k = 0， k = 1才有实践意义， 默认为 k = 1）**， ==SLR== 为简单 LR。

==LR== 语法分析器和前面说的非递归的 ==LL(1)== 文法一样是表格驱动（也就是要打表）。

==LR== 文法的定义

存在一个移入-归约语法分析器，总是能够在某文法的最右句型的句柄出现在栈顶的时候识别出这个句柄，那么这个文法就是 ==LR== 的。

LR 文法的特点：

* 对于几乎所有程序设计语言，只要能写出上下文无关文法，就能构造出识别该结构的 LR 语法分析器。
* 最通用的无回溯移入-归约分析方法
* 能尽早地检测到错误
	* ==LR== 语法分析器的适用文法是 ==LL== 文法的真超类，一个L1 文法是 ==LR(k)== 文法的条件是当我们在一个最右句型中看到某个产生式的右部的时候，我们再往前看 k 个符号就可以决定是否使用这个产生式进行归约。

> 手动构造 ==LR== 分析器工作量比较大，一般使用类似于 ==Yacc== 的自动语法分析器生成工具。

分析能力：`!$LR(0) < SLR(1) < LALR(1) < LR(1)$`

**LR(0)文法**

一个文法 G 的一个 ==LR(0)== **项（item）** 就是 G 的一个产生式再加上一个位于它的右部某处的点， e.g., 产生式 `!$A \rightarrow XYZ$` 产生了四个项。

![example](./images/1529246822032.png)

![item](./images/1529246923159.png)

用规范 ==LR(0)== 项集族构造一个 DFA（确定的有穷自动机）。首先在文法 ==G\[S]== 上加上一个新开始符号 `!$S'$` 和产生式 `!$S' \rightarrow S$` 得到一个 ==增广文法（augmented grammar）`!$G'$`==

==Closure== 函数

![closure](./images/1529288516752.png)

==Goto== 函数（DFA 状态转移）

==`!$GOTO(I, X)$`== 定义为项集 `!$I$` 中所有形如 `!$A \rightarrow \alpha \cdot X \beta$` 的项对应的项 `!$A \rightarrow \alpha X \cdot \beta$` 的集合的闭包。

文法 G\[S] 的 ==LR(0)== 自动机的开始状态就是 ==Closure(`!$[S' \rightarrow S]$`)==, 如果在当前正处于状态 `!$j$`，如果下一个输入符号为 `!$a$` 且状态 `!$j$` 有一个在 `!$a$` 的转换，就移入a，否则按照当前所在状态的项集中选择一个产生式进行归约。

e.g. 对于文法

![LR grammar](./images/1529290212558.png)

通过上述思想首先构造出该文法的 ==LR(0)== 自动机（注意项集中的点比较小）

![DFA](./images/1529290127645.png)

## (p) 4. Intermediate code generator